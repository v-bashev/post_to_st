/*
 * generated by Xtext 2.23.0
 */
package su.nsk.iae.post.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import su.nsk.iae.post.poST.AddExpression;
import su.nsk.iae.post.poST.AndExpression;
import su.nsk.iae.post.poST.AssignmentStatement;
import su.nsk.iae.post.poST.CaseElement;
import su.nsk.iae.post.poST.CaseList;
import su.nsk.iae.post.poST.CaseStatement;
import su.nsk.iae.post.poST.CompExpression;
import su.nsk.iae.post.poST.Constant;
import su.nsk.iae.post.poST.EquExpression;
import su.nsk.iae.post.poST.ErrorProcessStatement;
import su.nsk.iae.post.poST.ExitStatement;
import su.nsk.iae.post.poST.Expression;
import su.nsk.iae.post.poST.ExternalVarDeclaration;
import su.nsk.iae.post.poST.ExternalVarInitDeclaration;
import su.nsk.iae.post.poST.ForList;
import su.nsk.iae.post.poST.ForStatement;
import su.nsk.iae.post.poST.FunctionBlock;
import su.nsk.iae.post.poST.GlobalVarDeclaration;
import su.nsk.iae.post.poST.GlobalVarInitDeclaration;
import su.nsk.iae.post.poST.IfStatement;
import su.nsk.iae.post.poST.InputOutputVarDeclaration;
import su.nsk.iae.post.poST.InputVarDeclaration;
import su.nsk.iae.post.poST.IntegerLiteral;
import su.nsk.iae.post.poST.Model;
import su.nsk.iae.post.poST.MulExpression;
import su.nsk.iae.post.poST.OutputVarDeclaration;
import su.nsk.iae.post.poST.PoSTPackage;
import su.nsk.iae.post.poST.PowerExpression;
import su.nsk.iae.post.poST.PrimaryExpression;
import su.nsk.iae.post.poST.ProcessStatusExpression;
import su.nsk.iae.post.poST.Program;
import su.nsk.iae.post.poST.RealLiteral;
import su.nsk.iae.post.poST.RepeatStatement;
import su.nsk.iae.post.poST.ResetTimerStatement;
import su.nsk.iae.post.poST.SetStateStatement;
import su.nsk.iae.post.poST.SignedInteger;
import su.nsk.iae.post.poST.SimpleSpecificationInit;
import su.nsk.iae.post.poST.StartProcessStatement;
import su.nsk.iae.post.poST.State;
import su.nsk.iae.post.poST.StatementList;
import su.nsk.iae.post.poST.StopProcessStatement;
import su.nsk.iae.post.poST.SubprogramControlStatement;
import su.nsk.iae.post.poST.SymbolicVariable;
import su.nsk.iae.post.poST.TempVarDeclaration;
import su.nsk.iae.post.poST.TimeLiteral;
import su.nsk.iae.post.poST.TimeoutStatement;
import su.nsk.iae.post.poST.UnaryExpression;
import su.nsk.iae.post.poST.VarDeclaration;
import su.nsk.iae.post.poST.VarInitDeclaration;
import su.nsk.iae.post.poST.VarList;
import su.nsk.iae.post.poST.WhileStatement;
import su.nsk.iae.post.poST.XorExpression;
import su.nsk.iae.post.services.PoSTGrammarAccess;

@SuppressWarnings("all")
public class PoSTSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PoSTGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PoSTPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PoSTPackage.ADD_EXPRESSION:
				sequence_AddExpression(context, (AddExpression) semanticObject); 
				return; 
			case PoSTPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case PoSTPackage.ASSIGNMENT_STATEMENT:
				sequence_AssignmentStatement(context, (AssignmentStatement) semanticObject); 
				return; 
			case PoSTPackage.CASE_ELEMENT:
				sequence_CaseElement(context, (CaseElement) semanticObject); 
				return; 
			case PoSTPackage.CASE_LIST:
				sequence_CaseList(context, (CaseList) semanticObject); 
				return; 
			case PoSTPackage.CASE_STATEMENT:
				sequence_CaseStatement(context, (CaseStatement) semanticObject); 
				return; 
			case PoSTPackage.COMP_EXPRESSION:
				sequence_CompExpression(context, (CompExpression) semanticObject); 
				return; 
			case PoSTPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case PoSTPackage.EQU_EXPRESSION:
				sequence_EquExpression(context, (EquExpression) semanticObject); 
				return; 
			case PoSTPackage.ERROR_PROCESS_STATEMENT:
				sequence_ErrorProcessStatement(context, (ErrorProcessStatement) semanticObject); 
				return; 
			case PoSTPackage.EXIT_STATEMENT:
				sequence_ExitStatement(context, (ExitStatement) semanticObject); 
				return; 
			case PoSTPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case PoSTPackage.EXTERNAL_VAR_DECLARATION:
				sequence_ExternalVarDeclaration(context, (ExternalVarDeclaration) semanticObject); 
				return; 
			case PoSTPackage.EXTERNAL_VAR_INIT_DECLARATION:
				sequence_ExternalVarInitDeclaration(context, (ExternalVarInitDeclaration) semanticObject); 
				return; 
			case PoSTPackage.FOR_LIST:
				sequence_ForList(context, (ForList) semanticObject); 
				return; 
			case PoSTPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case PoSTPackage.FUNCTION_BLOCK:
				sequence_FunctionBlock(context, (FunctionBlock) semanticObject); 
				return; 
			case PoSTPackage.GLOBAL_VAR_DECLARATION:
				sequence_GlobalVarDeclaration(context, (GlobalVarDeclaration) semanticObject); 
				return; 
			case PoSTPackage.GLOBAL_VAR_INIT_DECLARATION:
				sequence_GlobalVarInitDeclaration(context, (GlobalVarInitDeclaration) semanticObject); 
				return; 
			case PoSTPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case PoSTPackage.INPUT_OUTPUT_VAR_DECLARATION:
				sequence_InputOutputVarDeclaration(context, (InputOutputVarDeclaration) semanticObject); 
				return; 
			case PoSTPackage.INPUT_VAR_DECLARATION:
				sequence_InputVarDeclaration(context, (InputVarDeclaration) semanticObject); 
				return; 
			case PoSTPackage.INTEGER_LITERAL:
				sequence_IntegerLiteral(context, (IntegerLiteral) semanticObject); 
				return; 
			case PoSTPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case PoSTPackage.MUL_EXPRESSION:
				sequence_MulExpression(context, (MulExpression) semanticObject); 
				return; 
			case PoSTPackage.OUTPUT_VAR_DECLARATION:
				sequence_OutputVarDeclaration(context, (OutputVarDeclaration) semanticObject); 
				return; 
			case PoSTPackage.POWER_EXPRESSION:
				sequence_PowerExpression(context, (PowerExpression) semanticObject); 
				return; 
			case PoSTPackage.PRIMARY_EXPRESSION:
				sequence_PrimaryExpression(context, (PrimaryExpression) semanticObject); 
				return; 
			case PoSTPackage.PROCESS:
				sequence_Process(context, (su.nsk.iae.post.poST.Process) semanticObject); 
				return; 
			case PoSTPackage.PROCESS_STATUS_EXPRESSION:
				sequence_ProcessStatusExpression(context, (ProcessStatusExpression) semanticObject); 
				return; 
			case PoSTPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case PoSTPackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case PoSTPackage.REPEAT_STATEMENT:
				sequence_RepeatStatement(context, (RepeatStatement) semanticObject); 
				return; 
			case PoSTPackage.RESET_TIMER_STATEMENT:
				sequence_ResetTimerStatement(context, (ResetTimerStatement) semanticObject); 
				return; 
			case PoSTPackage.SET_STATE_STATEMENT:
				sequence_SetStateStatement(context, (SetStateStatement) semanticObject); 
				return; 
			case PoSTPackage.SIGNED_INTEGER:
				sequence_SignedInteger(context, (SignedInteger) semanticObject); 
				return; 
			case PoSTPackage.SIMPLE_SPECIFICATION_INIT:
				sequence_SimpleSpecificationInit(context, (SimpleSpecificationInit) semanticObject); 
				return; 
			case PoSTPackage.START_PROCESS_STATEMENT:
				sequence_StartProcessStatement(context, (StartProcessStatement) semanticObject); 
				return; 
			case PoSTPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case PoSTPackage.STATEMENT_LIST:
				sequence_StatementList(context, (StatementList) semanticObject); 
				return; 
			case PoSTPackage.STOP_PROCESS_STATEMENT:
				sequence_StopProcessStatement(context, (StopProcessStatement) semanticObject); 
				return; 
			case PoSTPackage.SUBPROGRAM_CONTROL_STATEMENT:
				sequence_SubprogramControlStatement(context, (SubprogramControlStatement) semanticObject); 
				return; 
			case PoSTPackage.SYMBOLIC_VARIABLE:
				sequence_SymbolicVariable(context, (SymbolicVariable) semanticObject); 
				return; 
			case PoSTPackage.TEMP_VAR_DECLARATION:
				sequence_TempVarDeclaration(context, (TempVarDeclaration) semanticObject); 
				return; 
			case PoSTPackage.TIME_LITERAL:
				sequence_TimeLiteral(context, (TimeLiteral) semanticObject); 
				return; 
			case PoSTPackage.TIMEOUT_STATEMENT:
				sequence_TimeoutStatement(context, (TimeoutStatement) semanticObject); 
				return; 
			case PoSTPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case PoSTPackage.VAR_DECLARATION:
				sequence_VarDeclaration(context, (VarDeclaration) semanticObject); 
				return; 
			case PoSTPackage.VAR_INIT_DECLARATION:
				sequence_VarInitDeclaration(context, (VarInitDeclaration) semanticObject); 
				return; 
			case PoSTPackage.VAR_LIST:
				sequence_VarList(context, (VarList) semanticObject); 
				return; 
			case PoSTPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			case PoSTPackage.XOR_EXPRESSION:
				sequence_XorExpression(context, (XorExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns AddExpression
	 *     Expression.Expression_1_0 returns AddExpression
	 *     XorExpression returns AddExpression
	 *     XorExpression.XorExpression_1_0 returns AddExpression
	 *     AndExpression returns AddExpression
	 *     AndExpression.AndExpression_1_0 returns AddExpression
	 *     CompExpression returns AddExpression
	 *     CompExpression.CompExpression_1_0 returns AddExpression
	 *     EquExpression returns AddExpression
	 *     EquExpression.EquExpression_1_0 returns AddExpression
	 *     AddExpression returns AddExpression
	 *     AddExpression.AddExpression_1_0 returns AddExpression
	 *
	 * Constraint:
	 *     (left=AddExpression_AddExpression_1_0 addOp=AddOperator right=MulExpression)
	 */
	protected void sequence_AddExpression(ISerializationContext context, AddExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.ADD_EXPRESSION__ADD_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.ADD_EXPRESSION__ADD_OP));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddExpressionAccess().getAddExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAddExpressionAccess().getAddOpAddOperatorEnumRuleCall_1_1_0(), semanticObject.getAddOp());
		feeder.accept(grammarAccess.getAddExpressionAccess().getRightMulExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AndExpression
	 *     Expression.Expression_1_0 returns AndExpression
	 *     XorExpression returns AndExpression
	 *     XorExpression.XorExpression_1_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0 returns AndExpression
	 *
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0 right=CompExpression)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightCompExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns AssignmentStatement
	 *     AssignmentStatement returns AssignmentStatement
	 *
	 * Constraint:
	 *     (variable=[SymbolicVariable|ID] value=Expression)
	 */
	protected void sequence_AssignmentStatement(ISerializationContext context, AssignmentStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.ASSIGNMENT_STATEMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.ASSIGNMENT_STATEMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.ASSIGNMENT_STATEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.ASSIGNMENT_STATEMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentStatementAccess().getVariableSymbolicVariableIDTerminalRuleCall_0_0_1(), semanticObject.eGet(PoSTPackage.Literals.ASSIGNMENT_STATEMENT__VARIABLE, false));
		feeder.accept(grammarAccess.getAssignmentStatementAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CaseElement returns CaseElement
	 *
	 * Constraint:
	 *     (caseList=CaseList statement=StatementList)
	 */
	protected void sequence_CaseElement(ISerializationContext context, CaseElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.CASE_ELEMENT__CASE_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.CASE_ELEMENT__CASE_LIST));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.CASE_ELEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.CASE_ELEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseElementAccess().getCaseListCaseListParserRuleCall_0_0(), semanticObject.getCaseList());
		feeder.accept(grammarAccess.getCaseElementAccess().getStatementStatementListParserRuleCall_2_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CaseList returns CaseList
	 *
	 * Constraint:
	 *     (caseListElement+=SignedInteger caseListElement+=SignedInteger*)
	 */
	protected void sequence_CaseList(ISerializationContext context, CaseList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CaseStatement
	 *     SelectionStatement returns CaseStatement
	 *     CaseStatement returns CaseStatement
	 *
	 * Constraint:
	 *     (cond=Expression caseElements+=CaseElement+ elseStatement=StatementList?)
	 */
	protected void sequence_CaseStatement(ISerializationContext context, CaseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CompExpression
	 *     Expression.Expression_1_0 returns CompExpression
	 *     XorExpression returns CompExpression
	 *     XorExpression.XorExpression_1_0 returns CompExpression
	 *     AndExpression returns CompExpression
	 *     AndExpression.AndExpression_1_0 returns CompExpression
	 *     CompExpression returns CompExpression
	 *     CompExpression.CompExpression_1_0 returns CompExpression
	 *
	 * Constraint:
	 *     (left=CompExpression_CompExpression_1_0 compOp=CompOperator right=EquExpression)
	 */
	protected void sequence_CompExpression(ISerializationContext context, CompExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.COMP_EXPRESSION__COMP_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.COMP_EXPRESSION__COMP_OP));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompExpressionAccess().getCompExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompExpressionAccess().getCompOpCompOperatorEnumRuleCall_1_1_0(), semanticObject.getCompOp());
		feeder.accept(grammarAccess.getCompExpressionAccess().getRightEquExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns Constant
	 *
	 * Constraint:
	 *     {Constant}
	 */
	protected void sequence_Constant(ISerializationContext context, Constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns EquExpression
	 *     Expression.Expression_1_0 returns EquExpression
	 *     XorExpression returns EquExpression
	 *     XorExpression.XorExpression_1_0 returns EquExpression
	 *     AndExpression returns EquExpression
	 *     AndExpression.AndExpression_1_0 returns EquExpression
	 *     CompExpression returns EquExpression
	 *     CompExpression.CompExpression_1_0 returns EquExpression
	 *     EquExpression returns EquExpression
	 *     EquExpression.EquExpression_1_0 returns EquExpression
	 *
	 * Constraint:
	 *     (left=EquExpression_EquExpression_1_0 equOp=EquOperator right=AddExpression)
	 */
	protected void sequence_EquExpression(ISerializationContext context, EquExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EQU_EXPRESSION__EQU_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EQU_EXPRESSION__EQU_OP));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEquExpressionAccess().getEquExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEquExpressionAccess().getEquOpEquOperatorEnumRuleCall_1_1_0(), semanticObject.getEquOp());
		feeder.accept(grammarAccess.getEquExpressionAccess().getRightAddExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProcessStatements returns ErrorProcessStatement
	 *     ErrorProcessStatement returns ErrorProcessStatement
	 *     Statement returns ErrorProcessStatement
	 *
	 * Constraint:
	 *     process=[Process|ID]?
	 */
	protected void sequence_ErrorProcessStatement(ISerializationContext context, ErrorProcessStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExitStatement
	 *     ExitStatement returns ExitStatement
	 *
	 * Constraint:
	 *     {ExitStatement}
	 */
	protected void sequence_ExitStatement(ISerializationContext context, ExitStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *     Expression.Expression_1_0 returns Expression
	 *
	 * Constraint:
	 *     (left=Expression_Expression_1_0 right=XorExpression)
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getRightXorExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExternalVarDeclaration returns ExternalVarDeclaration
	 *
	 * Constraint:
	 *     (const?='CONSTANT'? vars+=ExternalVarInitDeclaration+)
	 */
	protected void sequence_ExternalVarDeclaration(ISerializationContext context, ExternalVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExternalVarInitDeclaration returns ExternalVarInitDeclaration
	 *
	 * Constraint:
	 *     (varList=VarList type=DataTypeName)
	 */
	protected void sequence_ExternalVarInitDeclaration(ISerializationContext context, ExternalVarInitDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXTERNAL_VAR_INIT_DECLARATION__VAR_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXTERNAL_VAR_INIT_DECLARATION__VAR_LIST));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXTERNAL_VAR_INIT_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXTERNAL_VAR_INIT_DECLARATION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternalVarInitDeclarationAccess().getVarListVarListParserRuleCall_0_0(), semanticObject.getVarList());
		feeder.accept(grammarAccess.getExternalVarInitDeclarationAccess().getTypeDataTypeNameParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForList returns ForList
	 *
	 * Constraint:
	 *     (start=Expression end=Expression step=Expression?)
	 */
	protected void sequence_ForList(ISerializationContext context, ForList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForStatement
	 *     IterationStatement returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (variable=[SymbolicVariable|ID] forList=ForList statement=StatementList)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.FOR_STATEMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.FOR_STATEMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.FOR_STATEMENT__FOR_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.FOR_STATEMENT__FOR_LIST));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.ITERATION_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.ITERATION_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForStatementAccess().getVariableSymbolicVariableIDTerminalRuleCall_1_0_1(), semanticObject.eGet(PoSTPackage.Literals.FOR_STATEMENT__VARIABLE, false));
		feeder.accept(grammarAccess.getForStatementAccess().getForListForListParserRuleCall_3_0(), semanticObject.getForList());
		feeder.accept(grammarAccess.getForStatementAccess().getStatementStatementListParserRuleCall_5_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionBlock returns FunctionBlock
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             progInVars+=InputVarDeclaration | 
	 *             progOutVars+=OutputVarDeclaration | 
	 *             progInOutVars+=InputOutputVarDeclaration | 
	 *             progVars+=VarDeclaration | 
	 *             progTempVars+=TempVarDeclaration | 
	 *             progExternVars+=ExternalVarDeclaration
	 *         )* 
	 *         processes+=Process*
	 *     )
	 */
	protected void sequence_FunctionBlock(ISerializationContext context, FunctionBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GlobalVarDeclaration returns GlobalVarDeclaration
	 *
	 * Constraint:
	 *     (const?='CONSTANT'? (varsSimple+=VarInitDeclaration | varsAs+=GlobalVarInitDeclaration)+)
	 */
	protected void sequence_GlobalVarDeclaration(ISerializationContext context, GlobalVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GlobalVarInitDeclaration returns GlobalVarInitDeclaration
	 *
	 * Constraint:
	 *     (varList=VarList location=DIRECT_VARIABLE type=DataTypeName)
	 */
	protected void sequence_GlobalVarInitDeclaration(ISerializationContext context, GlobalVarInitDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.GLOBAL_VAR_INIT_DECLARATION__VAR_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.GLOBAL_VAR_INIT_DECLARATION__VAR_LIST));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.GLOBAL_VAR_INIT_DECLARATION__LOCATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.GLOBAL_VAR_INIT_DECLARATION__LOCATION));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.GLOBAL_VAR_INIT_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.GLOBAL_VAR_INIT_DECLARATION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGlobalVarInitDeclarationAccess().getVarListVarListParserRuleCall_0_0(), semanticObject.getVarList());
		feeder.accept(grammarAccess.getGlobalVarInitDeclarationAccess().getLocationDIRECT_VARIABLETerminalRuleCall_2_0(), semanticObject.getLocation());
		feeder.accept(grammarAccess.getGlobalVarInitDeclarationAccess().getTypeDataTypeNameParserRuleCall_4_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     SelectionStatement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (mainCond=Expression mainStatement=StatementList (elseIfCond+=Expression elseIfStatements+=StatementList)* elseStatement=StatementList?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputOutputVarDeclaration returns InputOutputVarDeclaration
	 *
	 * Constraint:
	 *     vars+=VarInitDeclaration+
	 */
	protected void sequence_InputOutputVarDeclaration(ISerializationContext context, InputOutputVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputVarDeclaration returns InputVarDeclaration
	 *
	 * Constraint:
	 *     vars+=VarInitDeclaration+
	 */
	protected void sequence_InputVarDeclaration(ISerializationContext context, InputVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns IntegerLiteral
	 *     NumericLiteral returns IntegerLiteral
	 *     IntegerLiteral returns IntegerLiteral
	 *
	 * Constraint:
	 *     (type=IntegerTypeName? value=SignedInteger)
	 */
	protected void sequence_IntegerLiteral(ISerializationContext context, IntegerLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     programs+=Program+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MulExpression
	 *     Expression.Expression_1_0 returns MulExpression
	 *     XorExpression returns MulExpression
	 *     XorExpression.XorExpression_1_0 returns MulExpression
	 *     AndExpression returns MulExpression
	 *     AndExpression.AndExpression_1_0 returns MulExpression
	 *     CompExpression returns MulExpression
	 *     CompExpression.CompExpression_1_0 returns MulExpression
	 *     EquExpression returns MulExpression
	 *     EquExpression.EquExpression_1_0 returns MulExpression
	 *     AddExpression returns MulExpression
	 *     AddExpression.AddExpression_1_0 returns MulExpression
	 *     MulExpression returns MulExpression
	 *     MulExpression.MulExpression_1_0 returns MulExpression
	 *
	 * Constraint:
	 *     (left=MulExpression_MulExpression_1_0 mulOp=MulOperator right=PowerExpression)
	 */
	protected void sequence_MulExpression(ISerializationContext context, MulExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.MUL_EXPRESSION__MUL_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.MUL_EXPRESSION__MUL_OP));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulExpressionAccess().getMulExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulExpressionAccess().getMulOpMulOperatorEnumRuleCall_1_1_0(), semanticObject.getMulOp());
		feeder.accept(grammarAccess.getMulExpressionAccess().getRightPowerExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutputVarDeclaration returns OutputVarDeclaration
	 *
	 * Constraint:
	 *     vars+=VarInitDeclaration+
	 */
	protected void sequence_OutputVarDeclaration(ISerializationContext context, OutputVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PowerExpression
	 *     Expression.Expression_1_0 returns PowerExpression
	 *     XorExpression returns PowerExpression
	 *     XorExpression.XorExpression_1_0 returns PowerExpression
	 *     AndExpression returns PowerExpression
	 *     AndExpression.AndExpression_1_0 returns PowerExpression
	 *     CompExpression returns PowerExpression
	 *     CompExpression.CompExpression_1_0 returns PowerExpression
	 *     EquExpression returns PowerExpression
	 *     EquExpression.EquExpression_1_0 returns PowerExpression
	 *     AddExpression returns PowerExpression
	 *     AddExpression.AddExpression_1_0 returns PowerExpression
	 *     MulExpression returns PowerExpression
	 *     MulExpression.MulExpression_1_0 returns PowerExpression
	 *     PowerExpression returns PowerExpression
	 *     PowerExpression.PowerExpression_1_0 returns PowerExpression
	 *
	 * Constraint:
	 *     (left=PowerExpression_PowerExpression_1_0 right=UnaryExpression)
	 */
	protected void sequence_PowerExpression(ISerializationContext context, PowerExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerExpressionAccess().getPowerExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPowerExpressionAccess().getRightUnaryExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PrimaryExpression
	 *     Expression.Expression_1_0 returns PrimaryExpression
	 *     XorExpression returns PrimaryExpression
	 *     XorExpression.XorExpression_1_0 returns PrimaryExpression
	 *     AndExpression returns PrimaryExpression
	 *     AndExpression.AndExpression_1_0 returns PrimaryExpression
	 *     CompExpression returns PrimaryExpression
	 *     CompExpression.CompExpression_1_0 returns PrimaryExpression
	 *     EquExpression returns PrimaryExpression
	 *     EquExpression.EquExpression_1_0 returns PrimaryExpression
	 *     AddExpression returns PrimaryExpression
	 *     AddExpression.AddExpression_1_0 returns PrimaryExpression
	 *     MulExpression returns PrimaryExpression
	 *     MulExpression.MulExpression_1_0 returns PrimaryExpression
	 *     PowerExpression returns PrimaryExpression
	 *     PowerExpression.PowerExpression_1_0 returns PrimaryExpression
	 *     UnaryExpression returns PrimaryExpression
	 *     PrimaryExpression returns PrimaryExpression
	 *
	 * Constraint:
	 *     (const=Constant | variable=[SymbolicVariable|ID] | procStatus=ProcessStatusExpression | nestExpr=Expression)
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, PrimaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessStatusExpression returns ProcessStatusExpression
	 *
	 * Constraint:
	 *     (process=[Process|ID] (active?='ACTIVE' | inactive?='INACTIVE' | stop?='STOP' | error?='ERROR'))
	 */
	protected void sequence_ProcessStatusExpression(ISerializationContext context, ProcessStatusExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Process returns Process
	 *
	 * Constraint:
	 *     (name=ID (procVars+=VarDeclaration | procTempVars+=TempVarDeclaration)* states+=State*)
	 */
	protected void sequence_Process(ISerializationContext context, su.nsk.iae.post.poST.Process semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             progInVars+=InputVarDeclaration | 
	 *             progOutVars+=OutputVarDeclaration | 
	 *             progInOutVars+=InputOutputVarDeclaration | 
	 *             progVars+=VarDeclaration | 
	 *             progTempVars+=TempVarDeclaration | 
	 *             progExternVars+=ExternalVarDeclaration
	 *         )* 
	 *         processes+=Process*
	 *     )
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns RealLiteral
	 *     NumericLiteral returns RealLiteral
	 *     RealLiteral returns RealLiteral
	 *
	 * Constraint:
	 *     (type=REAL_TYPE_NAME? rSig?='-'? value=REAL)
	 */
	protected void sequence_RealLiteral(ISerializationContext context, RealLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RepeatStatement
	 *     IterationStatement returns RepeatStatement
	 *     RepeatStatement returns RepeatStatement
	 *
	 * Constraint:
	 *     (statement=StatementList cond=Expression)
	 */
	protected void sequence_RepeatStatement(ISerializationContext context, RepeatStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.ITERATION_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.ITERATION_STATEMENT__STATEMENT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.REPEAT_STATEMENT__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.REPEAT_STATEMENT__COND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepeatStatementAccess().getStatementStatementListParserRuleCall_1_0(), semanticObject.getStatement());
		feeder.accept(grammarAccess.getRepeatStatementAccess().getCondExpressionParserRuleCall_3_0(), semanticObject.getCond());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ResetTimerStatement returns ResetTimerStatement
	 *     Statement returns ResetTimerStatement
	 *
	 * Constraint:
	 *     {ResetTimerStatement}
	 */
	protected void sequence_ResetTimerStatement(ISerializationContext context, ResetTimerStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SetStateStatement returns SetStateStatement
	 *     Statement returns SetStateStatement
	 *
	 * Constraint:
	 *     (state=[State|ID] | next?='NEXT')
	 */
	protected void sequence_SetStateStatement(ISerializationContext context, SetStateStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SignedInteger returns SignedInteger
	 *
	 * Constraint:
	 *     (iSig?='-'? value=INTEGER)
	 */
	protected void sequence_SignedInteger(ISerializationContext context, SignedInteger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleSpecificationInit returns SimpleSpecificationInit
	 *
	 * Constraint:
	 *     (type=DataTypeName value=Constant?)
	 */
	protected void sequence_SimpleSpecificationInit(ISerializationContext context, SimpleSpecificationInit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessStatements returns StartProcessStatement
	 *     StartProcessStatement returns StartProcessStatement
	 *     Statement returns StartProcessStatement
	 *
	 * Constraint:
	 *     process=[Process|ID]?
	 */
	protected void sequence_StartProcessStatement(ISerializationContext context, StartProcessStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     State returns State
	 *
	 * Constraint:
	 *     (name=ID looped?='LOOPED'? statement=StatementList timeout=TimeoutStatement?)
	 */
	protected void sequence_State(ISerializationContext context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementList returns StatementList
	 *
	 * Constraint:
	 *     statements+=Statement*
	 */
	protected void sequence_StatementList(ISerializationContext context, StatementList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessStatements returns StopProcessStatement
	 *     StopProcessStatement returns StopProcessStatement
	 *     Statement returns StopProcessStatement
	 *
	 * Constraint:
	 *     process=[Process|ID]?
	 */
	protected void sequence_StopProcessStatement(ISerializationContext context, StopProcessStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SubprogramControlStatement
	 *     SubprogramControlStatement returns SubprogramControlStatement
	 *
	 * Constraint:
	 *     {SubprogramControlStatement}
	 */
	protected void sequence_SubprogramControlStatement(ISerializationContext context, SubprogramControlStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SymbolicVariable returns SymbolicVariable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SymbolicVariable(ISerializationContext context, SymbolicVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.SYMBOLIC_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.SYMBOLIC_VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSymbolicVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TempVarDeclaration returns TempVarDeclaration
	 *
	 * Constraint:
	 *     vars+=VarInitDeclaration+
	 */
	protected void sequence_TempVarDeclaration(ISerializationContext context, TempVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TimeLiteral returns TimeLiteral
	 *     Constant returns TimeLiteral
	 *
	 * Constraint:
	 *     interval=INTERVAL
	 */
	protected void sequence_TimeLiteral(ISerializationContext context, TimeLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.TIME_LITERAL__INTERVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.TIME_LITERAL__INTERVAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeLiteralAccess().getIntervalINTERVALTerminalRuleCall_3_0(), semanticObject.getInterval());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TimeoutStatement returns TimeoutStatement
	 *
	 * Constraint:
	 *     ((const=Constant | variable=[SymbolicVariable|ID]) statement=StatementList)
	 */
	protected void sequence_TimeoutStatement(ISerializationContext context, TimeoutStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns UnaryExpression
	 *     Expression.Expression_1_0 returns UnaryExpression
	 *     XorExpression returns UnaryExpression
	 *     XorExpression.XorExpression_1_0 returns UnaryExpression
	 *     AndExpression returns UnaryExpression
	 *     AndExpression.AndExpression_1_0 returns UnaryExpression
	 *     CompExpression returns UnaryExpression
	 *     CompExpression.CompExpression_1_0 returns UnaryExpression
	 *     EquExpression returns UnaryExpression
	 *     EquExpression.EquExpression_1_0 returns UnaryExpression
	 *     AddExpression returns UnaryExpression
	 *     AddExpression.AddExpression_1_0 returns UnaryExpression
	 *     MulExpression returns UnaryExpression
	 *     MulExpression.MulExpression_1_0 returns UnaryExpression
	 *     PowerExpression returns UnaryExpression
	 *     PowerExpression.PowerExpression_1_0 returns UnaryExpression
	 *     UnaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     right=PrimaryExpression
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getRightPrimaryExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclaration returns VarDeclaration
	 *
	 * Constraint:
	 *     (const?='CONSTANT'? vars+=VarInitDeclaration+)
	 */
	protected void sequence_VarDeclaration(ISerializationContext context, VarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarInitDeclaration returns VarInitDeclaration
	 *
	 * Constraint:
	 *     (varList=VarList spec=SimpleSpecificationInit)
	 */
	protected void sequence_VarInitDeclaration(ISerializationContext context, VarInitDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.VAR_INIT_DECLARATION__VAR_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.VAR_INIT_DECLARATION__VAR_LIST));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.VAR_INIT_DECLARATION__SPEC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.VAR_INIT_DECLARATION__SPEC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarInitDeclarationAccess().getVarListVarListParserRuleCall_0_0(), semanticObject.getVarList());
		feeder.accept(grammarAccess.getVarInitDeclarationAccess().getSpecSimpleSpecificationInitParserRuleCall_2_0(), semanticObject.getSpec());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarList returns VarList
	 *
	 * Constraint:
	 *     (vars+=SymbolicVariable vars+=SymbolicVariable*)
	 */
	protected void sequence_VarList(ISerializationContext context, VarList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileStatement
	 *     IterationStatement returns WhileStatement
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (cond=Expression statement=StatementList)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.WHILE_STATEMENT__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.WHILE_STATEMENT__COND));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.ITERATION_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.ITERATION_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getCondExpressionParserRuleCall_1_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getWhileStatementAccess().getStatementStatementListParserRuleCall_3_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns XorExpression
	 *     Expression.Expression_1_0 returns XorExpression
	 *     XorExpression returns XorExpression
	 *     XorExpression.XorExpression_1_0 returns XorExpression
	 *
	 * Constraint:
	 *     (left=XorExpression_XorExpression_1_0 right=AndExpression)
	 */
	protected void sequence_XorExpression(ISerializationContext context, XorExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PoSTPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXorExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
}
